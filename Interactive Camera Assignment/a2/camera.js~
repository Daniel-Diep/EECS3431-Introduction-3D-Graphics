var cameraLookFrom = vec3(5, 3, 8);
var cameraLookAt = vec3(0, 0, 0);
var cameraLookUp = vec3(0, 1, 0);
var fovY = 50;
var near = .1;
var far = 100;

var cameraVerticies;
var cameraBufferID;

var isMouseClicked;
var mouseStartingPosition;
var mouseCurrentPosition;
var mouseEndingPosition;
var isRightMouse;

function mouseButtonDown(x, y)
{
	isMouseClicked = true;
	mouseStartingPosition = vec2(x,y);
}

function mouseButtonUp(x,y)
{
	isMouseClicked = false;
}

function mouseMove(x,y)
{
	mouseCurrentPosition = vec2(x,y)
	/*
	//Controls panning along the x and y axes
	if(isMouseClicked && x >= (canvas.width * 1/2) && x < (canvas.width -1) && y >= 1 && y <= (canvas.height * 1/2))
	{
		if(isRightMouse)
		{
			fovY = fovY* (1+(mouseStartingPosition[1] - y) * 0.0001);
		}else{
			
		xRotation = toRadians(mouseStartingPosition[0] - x) * 0.01;
		yRotation = toRadians(mouseStartingPosition[1] - y)* 0.01;
		var oldLookAt = vec3(cameraLookAt[0],cameraLookAt[1],cameraLookAt[2]);
		
		//Set look at to origin
		cameraLookAt[0] = 0;
		cameraLookAt[1] = 0;
		cameraLookAt[2] = 0;
		
		var oldLookFrom = vec3(cameraLookFrom[0],cameraLookFrom[1],cameraLookFrom[2]);
		cameraLookFrom[0] = oldLookFrom[0] * Math.cos(xRotation) - oldLookFrom[2] * Math.sin(xRotation);
		cameraLookFrom[2] = oldLookFrom[0] * Math.sin(xRotation) + oldLookFrom[2] * Math.cos(xRotation);
	
		var oldLookFrom2 = vec3(cameraLookFrom[0],cameraLookFrom[1],cameraLookFrom[2]);
		cameraLookFrom[1] = oldLookFrom2[1] * Math.cos(yRotation) - oldLookFrom2[2] * Math.sin(yRotation);
		cameraLookFrom[2] = oldLookFrom2[1] * Math.sin(yRotation) + oldLookFrom2[2] * Math.cos(yRotation);
		
		//Set camera to look at original point
		cameraLookAt[0] = oldLookAt[0];
		cameraLookAt[1] = oldLookAt[1];
		cameraLookAt[2] = oldLookAt[2];
		
		}
	}else
	{
		isMouseClicked = false;
	}
	*/
	
	//document.getElementById("ScreenInfo").innerHTML = "(" + x + ", " +y + ")";
	document.getElementById("ScreenInfo").innerHTML = mouseCurrentPosition;
	//document.getElementById("ScreenInfo").innerHTML =  "camLookat: " + cameraLookAt[0]+ ", " +cameraLookAt[1] + "," +cameraLookAt[2];
	//document.getElementById("ScreenInfo").innerHTML =  "camLookFrom: " + cameraLookFrom[0]+ ", " +cameraLookFrom[1] + "," +cameraLookFrom[2];
	//document.getElementById("ScreenInfo").innerHTML =  "camLookup: " + cameraLookUp[0]+ ", " +cameraLookUp[1] + "," +cameraLookUp[2];
	//document.getElementById("ScreenInfo").innerHTML = "MiddleX" + middleX + ", MiddleY: " + middleY ;

}


function initCamera()
{
	// your code goes here
	cameraBufferID = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, cameraBufferID);
	gl.bufferData(gl.ARRAY_BUFFER, 16*64, gl.STATIC_DRAW);
}

function computeCameraOrientation()
{
	// your code goes here
	
	
	
	
	
}


function computeCameraOrientationTEMP(newMousePosition)
{
	// your code goes here
	
	
	
}

function drawCameraControls()
{
	// your code goes here
	cameraVerticies = [];
	gl.uniform4fv(objectColor, white);
	cameraVerticies.push(vec4(cameraLookAt));
	cameraVerticies.push(vec4(cameraLookFrom)); //test for changes to lookFrom
	cameraVerticies.push(vec4(add(cameraLookUp,cameraLookFrom)));
	gl.bufferSubData(gl.ARRAY_BUFFER, 0, flatten(cameraVerticies));
	gl.drawArrays(gl.LINE_STRIP, 0, cameraVerticies.length);
	
	/*cameraVerticies = [];
	gl.uniform4fv(objectColor, white);
	cameraVerticies.push(vec4(cameraLookAt));
	cameraVerticies.push(vec4(cameraLookFrom));
	cameraVerticies.push(vec4(add(cameraLookUp,cameraLookFrom)));
	gl.bufferSubData(gl.ARRAY_BUFFER, 0, flatten(cameraVerticies));
	gl.drawArrays(gl.LINE_STRIP, 0, cameraVerticies.length);
	*/
	
}

function scrollWheelZoom(isZoomUp)
{
	//Zoom in and out
	if(isZoomUp)
	{

		fovY += 5;	

	}else
	{
		fovY -= 5;
	}
	console.log("fov: " + fovY);
}
